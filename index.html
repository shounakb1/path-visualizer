<!doctype html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous"><link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600&display=swap" rel="stylesheet"><style>body{background-color:#f5f5f5;font-size:17px;color:#000;text-align:justify}.main{margin-left:15px;margin-right:15px}.main-h1{color:#167af6;margin-bottom:10px;margin-top:15px}.main-intro{font-size:17px}.welcome{color:#f37121}.caution{color:red;font-size:larger;font-weight:500}.main-h2{color:#167af6;margin-bottom:10px;margin-top:10px}.links{color:#ff427f;text-decoration:none;font-weight:600}.pseudo-code-snippet{background-color:#ddd;color:#000;margin-left:16px;margin-right:16px}.algo-tab{font-family:Poppins,sans-serif}.node-img{height:25px;width:25px}</style><title>Shortest Path Algorithm Visualizer</title><link href="/path-visualizer/static/css/main.37884775.chunk.css" rel="stylesheet"></head><body><div class="main"><h1 class="main-h1">Shortest Path Algorithms Visualizer</h1><p class="main-intro"><b><span class="welcome">Welcome</span></b> to Shortest Path Algorithms Visualizer. This is a tool to help you visualize how the algorithms, used for solving Shortest Path Problem, work in real time.</p><p>So, what is the <b>Shortest Path Problem ?</b></p><h2 class="main-h2">Shortest Path Problem</h2><p>The shortest path problem in graph theory, is a <a class="links" href="https://en.wikipedia.org/wiki/Combinatorial_optimization">Combinatorial Optimization</a> problem. The problem requires one to find a path between a source and a destination, such that travelling through the found path, costs the least. For the sake of problem-solving, this problem is interesting enough to try and solve. However, what makes this, one of the most-studied combinatorial optimization problem is the real life scenarios, that deal with this problem, as their primary application or as a subproblem of their primary application. Below are a few examples of such real life scenarios:</p><ul><li>Finding Shortest Path between two places in applications like GPS-enabled Google Maps, Waze. <a class="links" href="https://mathsection.com/how-google-maps-calculates-the-shortest-route/">How does this work ?</a></li><li>Used in IP routing. IP routing uses <a class="links" href="https://en.wikipedia.org/wiki/Open_Shortest_Path_First">Open Shortest Path First (OSPF)</a> routing protocol, that uses a shortest path problem solving algorithm named as Dijkstra's algorithm.</li><li>Communication Networks use shortest path problem solving algorithms to minimize network wide cost and regulate network traffic flows.</li></ul><p>Over the time, <a class="links" href="https://en.wikipedia.org/wiki/Shortest_path_problem#Algorithms">various algorithms</a> has been conceived to solve the shortest path problem. These algorithms both have their own advantages and disadvantages depending on the applications, they are used in. Here, however, only few of them has been implemented for visualization.</p><p>These are:</p><ul><li>BFS(Breadth First Search)</li><li>Dijkstra's Algorithm</li><li>Bellman Ford Algorithm</li><li>Floyd Warshall Algorithm</li></ul><p></p><p class="caution">It is strongly recommended to go through the algorithms first, then proceed to visualization.</p><ul class="nav nav-pills mb-3 algo-tab" id="pills-tab" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="pills-home-tab" data-toggle="pill" href="#pills-BFS" role="tab" aria-controls="pills-home" aria-selected="true">Breadth First Search</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="pills-profile-tab" data-toggle="pill" href="#pills-dijkstra" role="tab" aria-controls="pills-profile" aria-selected="false">Dijkstra's Algorithm</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="pills-contact-tab" data-toggle="pill" href="#pills-bellman-ford" role="tab" aria-controls="pills-contact" aria-selected="false">Bellman Ford Algorithm</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="pills-contact-tab" data-toggle="pill" href="#pills-floyd-warshall" role="tab" aria-controls="pills-contact" aria-selected="false">Floyd Warshall Algorithm</a></li></ul><div class="tab-content" id="pills-tabContent"><div class="tab-pane fade show active bfs" id="pills-BFS" role="tabpanel" aria-labelledby="pills-home-tab"><p>Breadth First Search is a Single-Source-Shortest-Path (SSSP) graph traversal algorithm <b>for unweighted graph</b>, in which we visit the source vertex first and mark it as visited. Then we visit all <b>adjacent, not-visited</b> vertices of the source vertex, mark them visited and then we visit adjacent, not-visited vertices of these vertices and so on..</p><p>Also, BFS with simple modification <a class="links" href="https://cp-algorithms.com/graph/01_bfs.html">(0-1 BFS)</a> can give shortest path from source to destination for <b>binary weighted</b> graph.</p><ul><li><b>Idea behind the algorithm</b><ul><li><p>Since during breadth first search, total encounterd distance keeps increasing by 1, <b>i.e.</b> we first travel source vertex (at distance 0), then travel vertices, those are at distance 1 from source, then vertices at distance 2 from source and so on, hence, the first time we encounter a vertex, the distance covered till now, must be the shortest distance.</p></li></ul></li></ul><pre class="pseudo-code-snippet"><code>
            function BFS(Graph[V], source, destination) {
              1. initialize distance[V] = {INF, INF, INF, INF,.......}
              2. distance[source] = 0
              3. create an empty Queue (say 'q')
              4. add source vertex to q
              5. while (q is not empty) 
                    vertex u := q.dequeue() {
                    for (all vertices v: adjacent of u) {
                        if (distance[v] == INF) {             // if vertex is not visited
                            distance[v] = distance[u] + 1
                            q.enqueue(v)
                        }
                    }
              }
              6. return distance[destination]
            }
          </code></pre><ul><li><b>Time Complexity:</b><ul><li><b>O(V+E)</b>, where V = number of vertices and E = number of edges</li></ul></li></ul><ul><li><b>Pros</b><ul><li>Gives shortest path for unweighted graph</li><li>Works for both <b>directed & undirected</b> graph</li><li>Easy to implement</li></ul></li><li><b>Cons</b><ul><li>Does <b>not</b> work for weighted graph</li></ul></li></ul></div><div class="tab-pane fade dijkstra" id="pills-dijkstra" role="tabpanel" aria-labelledby="pills-profile-tab"><p>Dijkstra's Shortest-Path-First (SPF) algorithm is a greedy single-source-shortest-path algorithm, conceived by <a class="links" href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Edsger. W Dijkstra</a> in 1956.</p><ul><li><b>Idea behind the algorithm</b><ul><li>We maintain a container of distance for all vertices initialized with values Infinite.</li><li>Distance of source vertex is 0.</li><li>At each iteration, we pick a vertex and finalize it distance. Initially none of the vertices have their distance finalized.</li><li><b>How do we pick the vertex ?</b><ul><li>We pick the vertex for which distance has not been finalized and has minimum distance. (greedy choice)</li></ul></li><li>Then we go to all adjacent vertices of it, and check whether do we get a shorter path to those vertices, through current vertex, If yes, then we update it's distance.</li></ul></li></ul><pre class="pseudo-code-snippet"><code>
            function Dijkstra(Graph[V], source, destination) {
              1. create a Priority Queue (Min Heap), say 'pq'
              2. intialize distance[V] = {INF, INF, INF, INF, INF,........}
              3. distance[source] = 0
              4. insert all vertices with distance[vertex] to pq                // O(V) time
              5. while (pq is not empty) {                                      // loop runs V times
                    vertex u := extract vertex with minimum distance from pq    // O(log V) time, overall time: O(V log V)
                    if (u == destination) {
                      return distance[destination]
                    }
                    for (all vertices v: adjacent of u) {
                      if (distance[v] > distance[u] + weight(u, v)) {
                        distance[v] = distance[u] + weight(u, v)
                        insert vertex v with distance[v] to pq                  // overall time: O(E log V)
                      }
                    }
              }
            }
          </code></pre><ul><li><b>Time Complexity:</b><ul><li><b>O(Vlog V + Elog V)</b>, where V = number of vertices and E = number of edges</li></ul></li></ul><ul><li><b>Pros</b><ul><li>Works for both <b>weighted & unweighted</b> graph</li><li>Works for both <b>cyclic & acyclic</b> graph</li><li>Works for both <b>directed & undirected</b> graph</li></ul></li><li><b>Cons</b><ul><li>Does <b>not</b> work for graph with negative weighted edges</li></ul></li></ul></div><div class="tab-pane fade bellman-ford" id="pills-bellman-ford" role="tabpanel" aria-labelledby="pills-contact-tab"><p>Bellman Ford shortest path algorithm is a dynamic programming based algorithm that computes from source node all reachable nodes. This algorithm was proposed by Alfonso Shimbel and was named after it's publishers Richard Bellman and Lester Ford Jr. .Even though this algorithm is relatively <b>slower than Dijkstra's algorithm</b>, it has one major advantage that, it <b>can detect negative weighted edge cycles</b>.</p><ul><li><b>Idea behind the algorithm</b><ul><li>The key idea of the algorithm is <b>If there are V vertices in a graph (that does not contain negative weighted edge cycles), then any existing shortest path, between any source and destination vertex can not have length more than V-1</b>.</li><li>We first find out the shortest path containing 1 edge, then shortest path containing 2 edges, then 3 edges and so on..</li></ul></li></ul><pre class="pseudo-code-snippet"><code>
            function BellmanFord(Graph[V], source, destination) {
              1. intialize distance[V] = {INF, INF, INF, INF, INF,........}
              2. distance[source] = 0
              3. for (count 0 to V-1) {
                    for (every edge u to v) {
                        if (distance[v] > distance[u] + weight(u, v)) {
                          distance[v] = distance[u] + weight(u, v)
                        }
                    }
              }

              /*
              For detection of negative weighted edge cycles,
              we run one more loop to check whether finalized 
              distances are further reducing or not. If yes,
              then report negative weighted edge cycle
              */
              4. for (every edge u to v) {
                  if (distance[v] > distance[u] + weight(u, v)) {
                    report (negative weighted edge cycle exists)
                    return
                  }
              }
              5. return distance[detination]
            }
          </code></pre><ul><li><b>Time Complexity:</b><ul><li><b>O(VE)</b>, where V = number of vertices and E = number of edges</li></ul></li></ul><ul><li><b>Pros</b><ul><li>Works for both <b>weighted & unweighted</b> graph</li><li>Works for both <b>cyclic & acyclic</b> graph</li><li>Works for both <b>directed & undirected</b> graph</li><li>Works for <b>negative weight edges</b></li><li>Detects negative weight edge cycles, if any</li></ul></li><li><b>Cons</b><ul><li>slower than Dijkstra's algorithm</li></ul></li></ul></div><div class="tab-pane fade floyd-warshall" id="pills-floyd-warshall" role="tabpanel" aria-labelledby="pills-contact-tab"><p>Floyd Warshall All-Pair-Shortest-Path (APSP) algorithm is a dynamic programming based algorithm, that computes shortest distances between all possible pair(source, destination) of vertices. This algorithm is relatively slower than even Bellman Ford algorithm. For even slightly higher number of vertices this algorithm takes quite some time to compute all pair shortest paths.</p><p>The crucial advantage of this algorithm is that, after computation, it gives shortest paths among all possible pairs of source and destination vertex, iff path exists.</p><ul><li><b>Idea behind the algorithm</b><ul><li>For each vertex, we update all shortest path from any source to any destination vertex, that contains this vertex as an intermediate vertx.</li><li>For all pairs of source to destination, we check whether through this intermediate vertex, a shorter path is possible or not.</li></ul></li></ul><pre class="pseudo-code-snippet"><code>
            function FloydWarshall(Graph[V], source, destination) {
              1. intialize distance[V][V]
              2. for (i from 1 to V) {
                    for (j from 1 to V) {
                        if (edge from i to j exists) {
                          distance[i][j] = weight(i, j)
                        }
                        else if (i == j) {
                          distance[i][j] = 0
                        }
                        else {
                          distance[i][j] = INF
                        }
                    }
              }
              3. for (k from 1 to V) {
                    for (i from 1 to V) {
                        for (j from 1 to V) {
                            if (distance[i][k] === INF || distance[k][j] === INF) {
                              continue
                            }
                            if (distance[i][j] > distance[i][k] + distance[k][j]) {
                              distance[i][j] = distance[i][k] + distance[k][j]
                            }
                        }
                    }
              }
              4. return distance[source][destination]
            }
          </code></pre><ul><li><b>Time Complexity:</b><ul><li><b>O(V³)</b>, where V = number of vertices</li></ul></li></ul><ul><li><b>Pros</b><ul><li>Works for both <b>weighted & unweighted</b> graph</li><li>Works for both <b>cyclic & acyclic</b> graph</li><li>Works for both <b>directed & undirected</b> graph</li><li>Works for <b>negative weight edges</b></li><li>Detects negative weight edge cycles, if any</li></ul></li><li><b>Cons</b><ul><li>Time Complexity very high</li></ul></li></ul></div></div><p><button class="btn btn-info" type="button" data-toggle="collapse" data-target="#collapseExample" aria-expanded="false" aria-controls="collapseExample">Instructions for Visualizer</button> <button class="btn btn-info" type="button" data-toggle="collapse" data-target="#color-code" aria-expanded="false" aria-controls="collapseExample">Reference for color coding</button> <button class="btn btn-warning" type="button" data-toggle="collapse" data-target="#warnings" aria-expanded="false" aria-controls="collapseExample">Warning</button></p><div class="collapse" id="collapseExample"><div class="card card-body"><p>Select an algorithm from dropdown</p><p>Visualize the algorithm</p><p>Clear Path or Reconfigure the Grid</p><p>Continue from the beginning</p></div></div><div class="collapse" id="color-code"><div class="card card-body"><p><img src="./images/2.png" class="node-img"> Source Node</p><p><img src="./images/3.png" class="node-img"> Destination Node</p><p><img src="./images/6.png" class="node-img"> Node present in the shortest path from source to destination</p><p><img src="./images/4.png" class="node-img"> Node, for which shortest distance has been finalized</p><p><img src="./images/5.png" class="node-img"> Node, which has been visited atleast once</p><p><img src="./images/8.png" class="node-img"><b><i>(only for Floyd Warshall Algorithm visualization)</i></b> Current Intermediate Node, that is being processed</p><p><img src="./images/9.png" class="node-img"><b><i>(only for Floyd Warshall Algorithm visualization)</i></b> Node, which has been visited atleast once</p></div></div><div class="collapse" id="warnings"><div class="card card-body"><p>For <b>Bellman Ford algorithm</b> visualization, <b>in worst case</b>, it takes around <b>2.5 minutes</b> to visualize the complete animation (despite all my efforts to optimize it without losing significant visualization details). Even though <b>on average</b> it takes around <b>1.5 minutes</b> to complete the animations.</p><p>For <b>Floyd Warshall Algorithm</b> visualization, I have disabled the animations for <b>current source Node</b> and <b>current destination Node</b>, that are being processed. Animations are enabled only for <b>current intermediate Node</b>. The reason being:</p><ul><li>For the 10 × 10 grid, there are 100 possible vertices. The algorithm has <b>cubic time complexity</b>.</li><li>For 100 vertices: 10,00,000 units of animation lapse duration takes a lot of time.</li><li>It took around 15 minutes, with all animation enabled with optimal animation lapse timing for proper visualization.</li></ul><p></p></div></div><div id="root"></div></div><script src="../src/index.js" type="text/JSX"></script><script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script><script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV" crossorigin="anonymous"></script><script>!function(e){function t(t){for(var n,i,a=t[0],l=t[1],p=t[2],c=0,s=[];c<a.length;c++)i=a[c],Object.prototype.hasOwnProperty.call(o,i)&&o[i]&&s.push(o[i][0]),o[i]=0;for(n in l)Object.prototype.hasOwnProperty.call(l,n)&&(e[n]=l[n]);for(f&&f(t);s.length;)s.shift()();return u.push.apply(u,p||[]),r()}function r(){for(var e,t=0;t<u.length;t++){for(var r=u[t],n=!0,a=1;a<r.length;a++){var l=r[a];0!==o[l]&&(n=!1)}n&&(u.splice(t--,1),e=i(i.s=r[0]))}return e}var n={},o={1:0},u=[];function i(t){if(n[t])return n[t].exports;var r=n[t]={i:t,l:!1,exports:{}};return e[t].call(r.exports,r,r.exports,i),r.l=!0,r.exports}i.m=e,i.c=n,i.d=function(e,t,r){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)i.d(r,n,function(t){return e[t]}.bind(null,n));return r},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="/path-visualizer/";var a=this["webpackJsonpshortest-path-visualizer"]=this["webpackJsonpshortest-path-visualizer"]||[],l=a.push.bind(a);a.push=t,a=a.slice();for(var p=0;p<a.length;p++)t(a[p]);var f=l;r()}([])</script><script src="/path-visualizer/static/js/2.67873438.chunk.js"></script><script src="/path-visualizer/static/js/main.0a8de688.chunk.js"></script></body></html>